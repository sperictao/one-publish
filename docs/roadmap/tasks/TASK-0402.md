# TASK-0402: Environment Probing + Guided Fixes

Status: done
Owner: OpenClaw
Links:
- PR: (tbd)

## Context

Users often struggle with environment setup:
- Missing tooling (cargo, dotnet, go, java)
- Wrong version of tools
- Missing build dependencies (native libraries)
- Incompatible OS configurations

OnePublish should detect these issues proactively and guide users to fix them, rather than failing cryptically at publish time.

## Goals

- Detect environment issues before publishing starts
- Provide clear, actionable guidance for each issue
- Support one-click fixes for common problems
- Support multiple platforms (macOS, Windows, Linux)

## Non-Goals

- Installing complex tooling automatically (security risk)
- Managing full dev environments (leave that to tools like nvm, sdkman)
- Detecting all possible edge cases (focus on common issues)

## User Stories

- As a developer, I want to know before publishing if cargo is not installed.
- As a developer, I want OnePublish to tell me exactly how to fix a missing tool.
- As a developer, I want OnePublish to open the download page for me.
- As a developer, I want to fix environment issues with a single click when possible.

## Requirements

### Functional

- R1: Detect installed providers and their versions
- R2: Detect common missing build dependencies
- R3: Provide fix guidance for each detected issue
- R4: Support one-click fixes (open download page, run install command)
- R5: Re-run environment check after fixes
- R6: Show environment status in Settings dialog

### Non-Functional

- N1: Cross-platform detection (macOS, Windows, Linux)
- N2: Fast detection (< 2 seconds)
- N3: Clear, actionable error messages
- N4: No false positives for environment issues

## UX Notes

### Entry Points

- Settings dialog: "Environment Check" button / status indicator
- Before publishing: Auto-run check, show warnings if issues found
- Provider selector: Show status icon (green/red) for each provider

### States

- **Environment Check Dialog:**
  - Scanning: spinner + "Checking environment..."
  - All good: ✅ "Your environment is ready"
  - Issues found: List each issue with fix button
  - After fix: "Re-check" button

- **Settings Status:**
  - Green check: All providers ready
  - Yellow warning: Some providers missing
  - Red error: Critical issues

### Issue Display

Each issue shows:
- Severity: Critical / Warning / Info
- Issue description: "Cargo not found"
- Fix button: "Install Cargo" / "Open Download Page" / "Run Command"
- Command preview (for command-based fixes): `brew install rust`

### Example Issues

```
Critical Issues:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
❌ Rust toolchain not found
   OnePublish needs cargo to publish Rust projects.

   Fix options:
   [Open Download Page] [Copy Install Command]

Warnings:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚠️  cargo version outdated
   Current: 1.70.0, Recommended: 1.75.0+
   You may encounter issues with newer projects.

   Fix: [Update Cargo]

Info:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ℹ️  Java detected, but no Java projects configured
   You can remove Java provider from settings to speed up startup.
```

### Empty/Error States

- **No providers configured:** "No language providers selected. Go to Settings to enable providers."
- **Scanning failed:** "Could not check environment. Please try again."
- **Fix failed:** "Could not apply fix. Please fix manually."

## Technical Design

### Data Model

#### Environment Issue

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentIssue {
    pub severity: IssueSeverity,
    pub provider_id: String,
    pub issue_type: IssueType,
    pub description: String,
    pub current_value: Option<String>,
    pub expected_value: Option<String>,
    pub fixes: Vec<FixAction>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IssueSeverity {
    Critical,  // Blocks publishing
    Warning,   // May cause issues
    Info,      // Suggestion
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IssueType {
    MissingTool,
    OutdatedVersion,
    MissingDependency,
    IncompatibleVersion,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FixAction {
    pub action_type: FixType,
    pub label: String,
    pub command: Option<String>,
    pub url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FixType {
    OpenUrl,
    RunCommand,
    CopyCommand,
    Manual,
}
```

#### Environment Check Result

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnvironmentCheckResult {
    pub is_ready: bool,
    pub providers: Vec<ProviderStatus>,
    pub issues: Vec<EnvironmentIssue>,
    pub checked_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProviderStatus {
    pub provider_id: String,
    pub installed: bool,
    pub version: Option<String>,
    pub path: Option<String>,
}
```

### API/Commands

#### Rust (Tauri Commands)

```rust
// Run full environment check
#[tauri::command]
pub async fn check_environment() -> Result<EnvironmentCheckResult, AppError> {
    // Detect all configured providers
    // Check each provider's environment
    // Collect issues
}

// Apply a fix action
#[tauri::command]
pub async fn apply_fix(action: FixAction) -> Result<FixResult, AppError> {
    match action.action_type {
        FixType::OpenUrl => {
            open::that(action.url.unwrap())?;
            Ok(FixResult::OpenedUrl)
        },
        FixType::RunCommand => {
            // Run command (user must approve)
            // Return output
        },
        FixType::CopyCommand => {
            // Copy to clipboard
        },
    }
}

// Get available fixes for a specific issue
#[tauri::command]
pub async fn get_fixes(issue_id: String) -> Result<Vec<FixAction>, AppError> {
    // Return applicable fixes
}
```

### Provider Detection Logic

#### Rust (Cargo)

```rust
pub fn check_cargo() -> Result<ProviderStatus, EnvironmentError> {
    // Run `cargo --version`
    // Parse version string
    // Check if it meets minimum requirements
}

pub fn detect_rust_toolchain() -> Vec<EnvironmentIssue> {
    let mut issues = Vec::new();

    // Check cargo exists
    match Command::new("cargo").arg("--version").output() {
        Ok(output) => {
            // Parse version, check minimum
            let version = parse_version(&output.stdout);
            if version < MIN_CARGO_VERSION {
                issues.push(EnvironmentIssue {
                    severity: IssueSeverity::Warning,
                    issue_type: IssueType::OutdatedVersion,
                    description: format!(
                        "cargo version outdated. Current: {}, Recommended: {}+",
                        version, MIN_CARGO_VERSION
                    ),
                    fixes: vec![FixAction {
                        action_type: FixType::RunCommand,
                        label: "Update Cargo",
                        command: Some("rustup update".to_string()),
                        url: None,
                    }],
                });
            }
        },
        Err(_) => {
            issues.push(EnvironmentIssue {
                severity: IssueSeverity::Critical,
                issue_type: IssueType::MissingTool,
                description: "Rust toolchain not found".to_string(),
                fixes: vec![
                    FixAction {
                        action_type: FixType::OpenUrl,
                        label: "Open Download Page",
                        command: None,
                        url: Some("https://rustup.rs/".to_string()),
                    },
                    FixAction {
                        action_type: FixType::RunCommand,
                        label: "Install via rustup",
                        command: Some("curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh".to_string()),
                        url: None,
                    },
                ],
            });
        }
    }

    issues
}
```

#### .NET (dotnet)

```rust
pub fn check_dotnet() -> Result<ProviderStatus, EnvironmentError> {
    // Run `dotnet --version`
    // Check SDK runtimes installed
}

pub fn detect_dotnet_environment() -> Vec<EnvironmentIssue> {
    // Similar pattern to Rust
}
```

#### Go

```rust
pub fn check_go() -> Result<ProviderStatus, EnvironmentError> {
    // Run `go version`
}
```

#### Java

```rust
pub fn check_java() -> Result<ProviderStatus, EnvironmentError> {
    // Run `java -version`
    // Run `javac -version`
}
```

### Platform-Specific Fixes

```rust
#[cfg(target_os = "macos")]
fn get_rust_fixes() -> Vec<FixAction> {
    vec![
        FixAction {
            action_type: FixType::RunCommand,
            label: "Install via Homebrew",
            command: Some("brew install rust".to_string()),
            url: None,
        },
        FixAction {
            action_type: FixType::RunCommand,
            label: "Install via rustup",
            command: Some("curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh".to_string()),
            url: None,
        },
    ]
}

#[cfg(target_os = "windows")]
fn get_rust_fixes() -> Vec<FixAction> {
    vec![
        FixAction {
            action_type: FixType::OpenUrl,
            label: "Download Installer",
            command: None,
            url: Some("https://rustup.rs/".to_string()),
        },
        FixAction {
            action_type: FixType::RunCommand,
            label: "Install via winget",
            command: Some("winget install Rustlang.Rustup".to_string()),
            url: None,
        },
    ]
}
```

### Frontend Integration

#### EnvironmentCheckDialog.tsx

```typescript
interface EnvironmentCheckDialogProps {
  open: boolean;
  onClose: () => void;
  onFixApplied?: () => void; // Re-check after fix
}

const EnvironmentCheckDialog: React.FC<EnvironmentCheckDialogProps> = ({
  open,
  onClose,
  onFixApplied,
}) => {
  const [checking, setChecking] = useState(false);
  const [result, setResult] = useState<EnvironmentCheckResult | null>(null);

  const handleCheck = async () => {
    setChecking(true);
    const res = await checkEnvironment();
    setResult(res);
    setChecking(false);
  };

  const handleFix = async (fix: FixAction) => {
    await applyFix(fix);
    onFixApplied?.();
    await handleCheck(); // Re-check
  };

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>Environment Check</DialogTitle>
      <DialogContent>
        {checking && <CircularProgress />}
        {result && (
          <>
            {result.issues.length === 0 && (
              <Alert severity="success">✅ Your environment is ready</Alert>
            )}
            {result.issues.map((issue) => (
              <EnvironmentIssueCard
                key={issue.id}
                issue={issue}
                onFix={handleFix}
              />
            ))}
          </>
        )}
      </DialogContent>
      <DialogActions>
        <Button onClick={handleCheck}>Re-check</Button>
        <Button onClick={onClose}>Close</Button>
      </DialogActions>
    </Dialog>
  );
};
```

## TDD Plan

### Test cases (write failing tests first)

#### Unit Tests

- [ ] `check_cargo` returns correct version when cargo is installed
- [ ] `check_cargo` returns error when cargo is not found
- [ ] `check_cargo` validates minimum version requirement
- [ ] `detect_rust_toolchain` returns critical issue for missing cargo
- [ ] `detect_rust_toolchain` returns warning for outdated version
- [ ] `check_dotnet` detects installed SDKs
- [ ] `check_dotnet` detects missing SDKs
- [ ] `check_go` detects installed Go version
- [ ] `check_java` detects installed Java version
- [ ] Platform-specific fixes are correct for each OS

#### Integration Tests

- [ ] `check_environment` returns correct provider statuses
- [ ] `check_environment` collects all issues across providers
- [ ] `apply_fix` opens URL correctly
- [ ] `apply_fix` runs command (mocked)
- [ ] `apply_fix` copies command to clipboard

#### E2E Tests

- [ ] User opens Environment Check dialog
- [ ] User sees critical issues
- [ ] User clicks fix button
- [ ] Fix is applied and environment is re-checked
- [ ] User sees "ready" status after all fixes
- [ ] Settings dialog shows environment status indicator

### Test types

- Unit: Provider detection logic, version parsing
- Integration: Command execution, fix application
- E2E: Full environment check workflow

## Acceptance Criteria

- [ ] AC1: `cargo test --manifest-path src-tauri/Cargo.toml` passes with environment tests
- [ ] AC2: User can run environment check from Settings
- [ ] AC3: Missing tools are detected with severity
- [ ] AC4: Critical issues prevent publishing with clear message
- [ ] AC5: Fixes are provided for common issues (open URL, run command)
- [ ] AC6: One-click fix opens download page or runs command
- [ ] AC7: Environment status is shown in Settings
- [ ] AC8: Re-check works after fixes are applied

## Rollout / Migration

- No migration required - new feature only
- Existing users: no impact, optional feature

## Notes

- **Security:** Don't run commands without user approval. Show command preview.
- **False positives:** Be conservative. Only flag real issues that block publishing.
- **Platform coverage:** Start with macOS and Windows, add Linux later.
- **Fix database:** Maintain a list of common issues and fixes for each provider.

### Minimum Version Requirements

- **Cargo:** 1.70.0
- **dotnet:** 6.0 SDK
- **Go:** 1.20
- **Java:** 11 (JDK)

### Open Questions

- Should environment check run automatically on app launch?
  - *Decision:* No, run on-demand or before publishing to avoid slow startup.
- Should environment check run before every publish attempt?
  - *Decision:* Yes, but cache results for 5 minutes to avoid redundant checks.
- Should we detect build dependencies (e.g., OpenSSL for Rust)?
  - *Decision:* Start with tooling only, add dependency detection later if needed.
