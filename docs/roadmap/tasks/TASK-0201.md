# TASK-0201: Provider Interface + Manifest + Loader

Status: done
Owner: OpenClaw
Links:
- Commits: 9c409ef

## Context

We now have:
- `PublishSpec` (language-agnostic)
- `ExecutionPlan` compiler (spec -> steps)
- initial error taxonomy

To become truly multi-language, we need a provider system so that adding Rust/Go/Java publishing does not require editing the core.

## Goals

- Define a `Provider` interface (trait) for compilation and metadata.
- Add a provider manifest (id/name/version/capabilities).
- Provide a loader/registry to resolve provider by id.

## Non-Goals

- Dynamic plugin loading from disk.
- Implementing Go/Java providers (tracked in TASK-0203/0204).

## Requirements

### Functional

- R1: Providers are registered in a central registry and resolved by `provider_id`.
- R2: Each provider supplies a manifest and a `compile(spec) -> ExecutionPlan` implementation.
- R3: Existing `dotnet` logic is moved behind the provider interface.

### Non-Functional

- N1: No IO in provider registry.
- N2: Deterministic compilation.

## Technical Design

- `src-tauri/src/provider/mod.rs`:
  - `ProviderManifest { id, display_name, version }`
  - `trait Provider { manifest(), compile(spec) }`
- `src-tauri/src/provider/registry.rs`:
  - `ProviderRegistry::new()` registers built-in providers
  - `get("dotnet") -> &dyn Provider`
- Wire `compiler::compile` to use the registry.

## TDD Plan

- [ ] Resolving unknown provider returns `UnsupportedProvider`.
- [ ] Resolving dotnet provider returns manifest with id `dotnet`.

## Acceptance Criteria

- [ ] AC1: `cargo test --manifest-path src-tauri/Cargo.toml` passes.
- [ ] AC2: Compiler uses provider registry instead of hardcoded match.
