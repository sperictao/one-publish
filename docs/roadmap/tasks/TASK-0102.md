# TASK-0102: ExecutionPlan Compiler (spec -> steps)

Status: doing
Owner: OpenClaw
Links:
- PR: (tbd)

## Context

We now have a language-agnostic `PublishSpec`. Next we need a deterministic compiler that turns it into an explicit `ExecutionPlan`.
This creates a stable boundary for:
- logging/observability
- unit testing
- future provider plugins

## Goals

- Introduce `ExecutionPlan` + `PlanStep` models.
- Add a `compile(spec) -> ExecutionPlan` entrypoint.
- Provide a first concrete compiler for the existing dotnet publish flow.

## Non-Goals

- Actually running the plan (execution engine can stay where it is for now).
- Full error taxonomy (tracked in TASK-0103).

## Requirements

### Functional

- R1: Compiling a dotnet spec produces a plan with ordered steps.
- R2: Each step has a stable id, human-readable title, and structured payload.
- R3: Plan can be serialized to JSON for debugging.

### Non-Functional

- N1: Compiler is pure (no filesystem IO, no process spawning).
- N2: Plan is deterministic.

## Technical Design

- Add `src-tauri/src/plan.rs`:
  - `ExecutionPlan { version, spec, steps }`
  - `PlanStep { id, title, kind, payload }`
- Add `src-tauri/src/compiler.rs`:
  - `compile(spec: &PublishSpec) -> Result<ExecutionPlan, CompileError>`
- First provider: `dotnet` (re-use existing argument generation logic).

## TDD Plan

### Test cases

- [ ] Given a minimal dotnet spec, compiler produces a plan with a single `dotnet.publish` step.
- [ ] Plan JSON round-trips.

## Acceptance Criteria

- [ ] AC1: `cargo test --manifest-path src-tauri/Cargo.toml` passes.
- [ ] AC2: At least 2 unit tests for the compiler.
