# TASK-0401: Config Import/Export

Status: done
Owner: OpenClaw
Links:
- PR: (tbd)

## Context

Users often need to:
- Share build configurations across team members
- Backup and restore publish settings
- Move configurations between machines
- Maintain multiple configuration profiles

Export/import provides a portable, shareable configuration format while ensuring sensitive data (like paths, credentials) is handled appropriately.

## Goals

- Export publish configuration to JSON file
- Import publish configuration from JSON file
- Support team sharing via configuration files
- Exclude or redact sensitive fields (paths, secrets)
- Validate imported configurations

## Non-Goals

- Online configuration sharing/cloud sync
- Configuration version control integration
- Automatic backup/sync across devices

## User Stories

- As a developer, I want to export my build configuration to share with my team.
- As a developer, I want to import a team's configuration file to get started quickly.
- As a developer, I want to save configuration profiles for different projects.
- As a developer, I want my local paths not to be shared when exporting configuration.

## Requirements

### Functional

- R1: Export PublishSpec + preset selections to JSON file
- R2: Import JSON file and restore PublishSpec + preset selections
- R3: Exclude machine-specific paths during export
- R4: Validate imported configuration against provider schemas
- R5: Show diff/preview before importing configuration
- R6: Support multiple saved configuration profiles

### Non-Functional

- N1: Exported JSON is human-readable and version-controllable
- N2: Import fails gracefully with clear error messages
- N3: Configuration format is backward compatible
- N4: Sensitive fields are clearly marked in export format

## UX Notes

### Entry Points

- Settings dialog: "Export Configuration" / "Import Configuration" buttons
- Preset dropdown: "Save as Profile" / "Manage Profiles"
- Right-click context menu on configuration panels

### States

- **Export:**
  - File picker dialog to save .json file
  - Confirmation: "Configuration exported to X profiles"

- **Import:**
  - File picker dialog to select .json file
  - Preview dialog showing what will be imported
  - Confirmation after import

- **Profile Management:**
  - List of saved profiles with delete/edit actions
  - Switch between profiles

### Empty/Error States

- **No saved profiles:** "No saved profiles. Save your current configuration to create one."
- **Invalid import:** "Could not import configuration. Invalid format or version mismatch."
- **Path conflicts:** "Imported configuration contains machine-specific paths. Review before applying."

## Technical Design

### Data Model

#### Configuration Export Format

```json
{
  "version": 1,
  "exported_at": "2026-02-03T14:00:00Z",
  "exported_by": "user@example.com",
  "profiles": [
    {
      "name": "Production - Windows",
      "provider_id": "dotnet",
      "parameters": {
        "configuration": "Release",
        "runtime": "win-x64",
        "self_contained": true
      }
    }
  ],
  "settings": {
    "theme": "dark",
    "language": "en"
  }
}
```

### API/Commands

#### Rust (Tauri Commands)

```rust
// Export current configuration
#[tauri::command]
pub async fn export_config(
    profiles: Vec<ConfigProfile>,
    settings: AppSettings,
) -> Result<String, AppError> {
    // Generate JSON
    // Return file path where it was saved
}

// Import configuration from file
#[tauri::command]
pub async fn import_config(
    file_path: String,
) -> Result<ImportedConfig, AppError> {
    // Parse JSON
    // Validate against schema
    // Return parsed config for preview
}

// Apply imported configuration
#[tauri::command]
pub async fn apply_imported_config(
    config: ImportedConfig,
) -> Result<(), AppError> {
    // Save to store
}

// Get saved profiles
#[tauri::command]
pub async fn get_profiles() -> Result<Vec<ConfigProfile>, AppError> {
    // Load from store
}

// Save current configuration as profile
#[tauri::command]
pub async fn save_profile(
    name: String,
    config: PublishSpec,
) -> Result<(), AppError> {
    // Store profile
}

// Delete profile
#[tauri::command]
pub async fn delete_profile(name: String) -> Result<(), AppError> {
    // Remove from store
}
```

### Storage

#### Profile Storage Structure

```rust
pub struct ConfigProfile {
    pub name: String,
    pub provider_id: String,
    pub parameters: BTreeMap<String, SpecValue>,
    pub created_at: DateTime<Utc>,
    pub is_system_default: bool,
}

pub struct ImportedConfig {
    pub version: u32,
    pub exported_at: String,
    pub profiles: Vec<ConfigProfile>,
    pub settings: AppSettings,
}
```

#### State Management (Frontend)

```typescript
interface Profile {
  id: string;
  name: string;
  providerId: string;
  parameters: Record<string, JsonValue>;
  createdAt: string;
  isSystemDefault: boolean;
}

interface ConfigExport {
  version: number;
  exportedAt: string;
  profiles: Profile[];
  settings: AppSettings;
}
```

### Path Handling

During export, exclude or redact:
- `project_path` - machine-specific
- `output_dir` if absolute - machine-specific
- Any paths in parameters - redact or replace with placeholders

```rust
pub fn sanitize_for_export(spec: &PublishSpec) -> PublishSpec {
    let mut sanitized = spec.clone();
    sanitized.project_path = String::new(); // Clear machine-specific path

    // Sanitize output_dir if absolute
    if let Some(SpecValue::String(output_dir)) = sanitized.parameters.get_mut("output") {
        if PathBuf::from(output_dir).is_absolute() {
            *output_dir = "<local-path>".to_string();
        }
    }

    sanitized
}
```

### Validation

During import, validate:
- Version compatibility
- Provider IDs exist
- Parameter keys match schema
- Parameter values are valid types

```rust
pub fn validate_import(config: &ImportedConfig) -> Result<(), ImportError> {
    // Check version
    if config.version > CONFIG_VERSION {
        return Err(ImportError::UnsupportedVersion(config.version));
    }

    // Validate each profile
    for profile in &config.profiles {
        let registry = ProviderRegistry::new();
        let provider = registry.get(&profile.provider_id)?;

        let schema = provider.get_schema()?;
        for (key, value) in &profile.parameters {
            if !schema.parameters.contains_key(key) {
                // Warning: unknown parameter, but allow it
            }
        }
    }

    Ok(())
}
```

## TDD Plan

### Test cases (write failing tests first)

#### Unit Tests

- [ ] `sanitize_for_export` removes machine-specific paths
- [ ] `sanitize_for_export` preserves relative paths
- [ ] `validate_import` rejects unknown versions
- [ ] `validate_import` rejects invalid provider IDs
- [ ] `validate_import` accepts valid configurations
- [ ] `export_config` produces valid JSON
- [ ] `import_config` parses valid JSON
- [ ] `import_config` rejects invalid JSON

#### Integration Tests

- [ ] Export â†’ Import roundtrip preserves configuration
- [ ] Imported configuration can be applied successfully
- [ ] Profile save/load persistence
- [ ] Profile deletion removes from storage

#### E2E Tests

- [ ] User exports configuration via settings dialog
- [ ] User imports configuration via settings dialog
- [ ] User saves current configuration as profile
- [ ] User switches between saved profiles
- [ ] Import preview shows correct diff

### Test types

- Unit: Path sanitization, validation logic
- Integration: File I/O, state persistence
- E2E: UI flows for import/export

## Acceptance Criteria

- [ ] AC1: `cargo test --manifest-path src-tauri/Cargo.toml` passes with config tests
- [ ] AC2: User can export configuration to JSON file
- [ ] AC3: User can import configuration from JSON file
- [ ] AC4: Exported configuration excludes machine-specific paths
- [ ] AC5: Imported configuration is validated before applying
- [ ] AC6: User can save multiple configuration profiles
- [ ] AC7: User can switch between profiles
- [ ] AC8: Import preview shows what will be imported

## Rollout / Migration

- No migration required - new feature only
- Existing users: no impact, optional feature

## Notes

- **Version handling:** Start with version 1, include version in export format for future compatibility
- **File format:** JSON is preferred for readability and version control
- **Security:** Never include API keys, tokens, or credentials in exported config
- **Future consideration:** Could add encryption for sensitive fields if needed

### Open Questions

- Should profiles be stored in the app state or a separate file?
  - *Decision:* Store in app state for now, can move to file if needed
- Should export include repository list?
  - *Decision:* No, exclude repository paths (machine-specific)
- Should import overwrite existing profiles or merge?
  - *Decision:* Show preview, let user choose merge/replace options
